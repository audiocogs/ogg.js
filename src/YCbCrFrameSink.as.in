#include "YCbCr-shaders-agal.h"

package {
	import flash.display.Stage;
	import flash.display3D.Context3D;
	import flash.display3D.Context3DBufferUsage;
	import flash.display3D.Context3DProgramType;
	import flash.display3D.Context3DTextureFormat;
	import flash.display3D.Context3DVertexBufferFormat;
	import flash.display3D.IndexBuffer3D;
	import flash.display3D.Program3D;
	import flash.display3D.VertexBuffer3D;
	import flash.display3D.textures.Texture;
	import flash.events.Event;
	import flash.utils.ByteArray;

	import com.adobe.utils.AGALMiniAssembler;


	public class YCbCrFrameSink {
		private var stage:Stage = null;
		private var debug:Boolean = false; // swap this to enable more error checks, which can slow down rendering
		
		private var context3D:Context3D = null;
		private var vertexShader:ByteArray = null;
		private var fragmentShader:ByteArray = null;
		private var program:Program3D = null;
		private var vertexBuffer:VertexBuffer3D;
		private var lumaPositionBuffer:VertexBuffer3D;
		private var chromaPositionBuffer:VertexBuffer3D;
		private var indices:IndexBuffer3D;
		private var textures:Object = {};
		private var videoInfo:Object = null;
		
		private var vertexShaderSource:Object = JSON.parse(YCBCR_VERTEX_SHADER);
		private var fragmentShaderSource:Object = JSON.parse(YCBCR_FRAGMENT_SHADER);
		
		public function YCbCrFrameSink(_stage:Stage, _videoInfo:Object) {
			stage = _stage;
			videoInfo = _videoInfo;

			if (stage.stage3Ds.length > 0) {
				stage.stage3Ds[0].addEventListener(Event.CONTEXT3D_CREATE, function(e:Event):void {
					context3D = stage.stage3Ds[0].context3D;
					context3D.enableErrorChecking = debug;
					//context3D.configureBackBuffer(videoInfo.picWidth, videoInfo.picHeight, 0, false);
					context3D.configureBackBuffer(stage.stageWidth, stage.stageHeight, 0, false);
				});
				stage.stage3Ds[0].requestContext3D();
			} else {
				throw new Error('Stage3D unavailable');
			}
			trace('Using Stage3D canvas for video drawing');
		}

		public function onResize():void {
			context3D.configureBackBuffer(stage.stageWidth, stage.stageHeight, 0, false);
		}

		private function compileShader(type:String, source:String):ByteArray {
			var assembler:AGALMiniAssembler = new AGALMiniAssembler();
			assembler.assemble(type, source);
			return assembler.agalcode;
		}
	
		// In the world of GL there are no rectangles.
		// There are only triangles.
		// THERE IS NO SPOON.
		private var rectangle:Vector.<Number> = new <Number>[
			// First triangle (top left, clockwise)
			-1.0, -1.0,
			+1.0, -1.0,
			-1.0, +1.0,

			// Second triangle (bottom right, clockwise)
			-1.0, +1.0,
			+1.0, -1.0,
			+1.0, +1.0
		];

		private function nextPowerOfTwo(val:int):int {
			var n:int = 1;
			while (n < val) {
				n *= 2;
			}
			return n;
		}

		private function attachTexture(name:String, index:int, width:int, height:int, data:ByteArray, offset:int):void {
			// We'll have to convert to power-of-2 size. Sighhh
			var texWidth:int = nextPowerOfTwo(width);
			var texHeight:int = nextPowerOfTwo(height);
			var texBytes:ByteArray = new ByteArray();
			var texStride:int = texWidth * 4;
			var stride:int = width * 4;
			texBytes.length = texStride * texHeight;
			for (var y:int = 0; y < height; y++) {
				texBytes.position = (height - 1 - y) * texStride;
				texBytes.writeBytes(data, offset + y * stride, stride);
			}
			
			var texture:Texture;
			if (textures[name]) {
				// Reuse & update the existing texture
				texture = textures[name];
			} else {
				textures[name] = texture = context3D.createTexture(texWidth, texHeight, Context3DTextureFormat.BGRA, false, 0);
			}
			
			texture.uploadFromByteArray(texBytes, 0, 0);
		
			context3D.setTextureAt(index, texture);
		}

		// Constants can't just sit in the shaders in AGAL, so we have to extract
		// the list from the GLSL->AGAL compiler and put them all into a big vector. 
		private function expandConstants(consts:Object):Vector.<Number> {
			var out:Vector.<Number> = new Vector.<Number>;
			var keys:Array = [];
			var register:String;

			for (register in consts) {
				// Warning: they come in out of order from foreach
				keys.push(register);
			}
			keys.sort();

			for each (register in keys) {
				for each (var val:Number in consts[register]) {
					out.push(val);
				}
			}
			return out;
		}
		
		private function registerForVar(shaderSource:Object, name:String):int {
			var vars:Object = shaderSource.varnames;
			var registerName:String = '';
			for (var key:String in vars) {
				if (key === name) {
					registerName = vars[key];
				}
			}
			if (registerName == '') {
				throw new Error('Could not find register for variable ' + name);
			}
			// We only need the register number; type is inherent.
			return parseInt(registerName.replace(/^[a-z]+/, ''));
		}

		private function init(yCbCrBuffer:Object):void {
			vertexShader = compileShader(Context3DProgramType.VERTEX, vertexShaderSource.agalasm);
			
			// The GLSL->AGAL compiler assumed we wanted linear sampling and repeat, which we don't
			var fragSource:String = fragmentShaderSource.agalasm.replace(/linear/g, 'nearest').replace(/repeat/g, 'clamp');
			fragmentShader = compileShader(Context3DProgramType.FRAGMENT, fragSource);
	
			program = context3D.createProgram();
			program.upload(vertexShader, fragmentShader);

			context3D.setProgram(program);

			// We also need to pass some constant values for the shaders!
			context3D.setProgramConstantsFromVector(Context3DProgramType.VERTEX, 0,
			                                        expandConstants(vertexShaderSource.consts));
			context3D.setProgramConstantsFromVector(Context3DProgramType.FRAGMENT, 0,
			                                        expandConstants(fragmentShaderSource.consts));
		
			function buildStripe(width:int):ByteArray {
				var out:ByteArray = new ByteArray();
				for (var i:int = 0; i < width; i += 4) {
					out.writeInt(0xff000000);
					out.writeInt(0x00ff0000);
					out.writeInt(0x0000ff00);
					out.writeInt(0x000000ff);
				}
				return out;
			}
		
			attachTexture(
				'uStripeLuma',
				registerForVar(fragmentShaderSource, 'uStripeLuma'),
				yCbCrBuffer.strideY,
				1,
				buildStripe(yCbCrBuffer.strideY),
				0
			);
			attachTexture(
				'uStripeChroma',
				registerForVar(fragmentShaderSource, 'uStripeChroma'),
				yCbCrBuffer.strideCb,
				1,
				buildStripe(yCbCrBuffer.strideCb),
				0
			);

			vertexBuffer = context3D.createVertexBuffer(rectangle.length / 2, 2, Context3DBufferUsage.STATIC_DRAW);
			vertexBuffer.uploadFromVector(rectangle, 0, rectangle.length / 2);

			var vertexCount:int = rectangle.length / 2;
			var indexVector:Vector.<uint> = new Vector.<uint>();
			for (var i:int = 0; i < vertexCount; i++) {
				indexVector.push(i);
			}
			indices = context3D.createIndexBuffer(vertexCount);
			indices.uploadFromVector(indexVector, 0, vertexCount);

			// Set up the texture geometry...
			function setupTexturePosition(varname:String, index:int, texWidth:int, texHeight:int):VertexBuffer3D {
				// Warning: assumes that the stride for Cb and Cr is the same size in output pixels
				var textureX0:Number = videoInfo.picX / nextPowerOfTwo(texWidth);
				var textureX1:Number = (videoInfo.picX + videoInfo.picWidth) / nextPowerOfTwo(texWidth);
				var textureY0:Number = videoInfo.picY / nextPowerOfTwo(texHeight);
				var textureY1:Number = (videoInfo.picY + videoInfo.picHeight) / nextPowerOfTwo(texHeight);
				var textureRectangle:Vector.<Number> = new <Number>[
					textureX0, textureY0,
					textureX1, textureY0,
					textureX0, textureY1,
					textureX0, textureY1,
					textureX1, textureY0,
					textureX1, textureY1
				];

				var texturePositionBuffer:VertexBuffer3D = context3D.createVertexBuffer(textureRectangle.length / 2, 2, Context3DBufferUsage.STATIC_DRAW);
				texturePositionBuffer.uploadFromVector(textureRectangle, 0, textureRectangle.length / 2);
				return texturePositionBuffer;
			}
			lumaPositionBuffer = setupTexturePosition('aLumaPosition', registerForVar(vertexShaderSource, 'aLumaPosition'), yCbCrBuffer.strideY, yCbCrBuffer.height);
			chromaPositionBuffer = setupTexturePosition('aChromaPosition', registerForVar(vertexShaderSource, 'aChromaPosition'), yCbCrBuffer.strideCb << yCbCrBuffer.hdec, yCbCrBuffer.height);
		}
	
		public function drawFrame(yCbCrBuffer:Object):void {
			if (!context3D) {
				trace('context not yet initialized');
				return;
			}
			if (!program) {
				trace('initializing gl program');
				init(yCbCrBuffer);
			}

			context3D.clear();

			// Set up the rectangle and draw it

			//
			// Set up geometry
			//
			context3D.setVertexBufferAt(registerForVar(vertexShaderSource, 'aPosition'), vertexBuffer, 0, Context3DVertexBufferFormat.FLOAT_2);
			context3D.setVertexBufferAt(registerForVar(vertexShaderSource, 'aLumaPosition'), chromaPositionBuffer, 0, Context3DVertexBufferFormat.FLOAT_2);
			context3D.setVertexBufferAt(registerForVar(vertexShaderSource, 'aChromaPosition'), lumaPositionBuffer, 0, Context3DVertexBufferFormat.FLOAT_2);
		
			// Create the textures...
			attachTexture(
				'uTextureY',
				registerForVar(fragmentShaderSource, 'uTextureY'),
				yCbCrBuffer.strideY / 4,
				yCbCrBuffer.height,
				yCbCrBuffer.bytes,
				yCbCrBuffer.bufferY
			);
			attachTexture(
				'uTextureCb',
				registerForVar(fragmentShaderSource, 'uTextureCb'),
				yCbCrBuffer.strideCb / 4,
				yCbCrBuffer.height >> yCbCrBuffer.vdec,
				yCbCrBuffer.bytes,
				yCbCrBuffer.bufferCb
			);
			attachTexture(
				'uTextureCr',
				registerForVar(fragmentShaderSource, 'uTextureCr'),
				yCbCrBuffer.strideCr / 4,
				yCbCrBuffer.height >> yCbCrBuffer.vdec,
				yCbCrBuffer.bytes,
				yCbCrBuffer.bufferCr
			);

			// Aaaaand draw stuff.
			context3D.drawTriangles(indices, 0);
			context3D.present();
		};
	}

}
